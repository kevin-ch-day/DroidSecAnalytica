# db_malware_classification.py

from typing import Optional, Dict, List, Any
from . import db_conn
from utils import logging_utils

logger = logging_utils.get_logger(__name__)

# Executes an SQL query and returns results as a list of dictionaries
def fetch_results(sql: str, params: tuple = ()) -> Optional[List[Dict]]:
    try:
        return db_conn.execute_query(sql, params, fetch=True) or None
    except Exception:
        logger.exception("SQL Error: %s | Params: %s", sql, params)
        return None

# Fetches malware classification data, including VirusTotal engine results, for a given SHA-256 hash
def get_malware_classification_details(sha256: str) -> Optional[Dict]:
    sql = """
        SELECT 
            m.id,
            m.malware_name,
            m.malware_family,
            m.virustotal_label,
            s.AhnLab_V3,
            s.Alibaba,
            s.Ikarus,
            s.Kaspersky,
            s.Microsoft,
            s.Tencent,
            s.ZoneAlarm
        FROM malware_samples m
        JOIN vt_scan_analysis s
            ON s.apk_id = m.id
        WHERE m.sha256 = %s
        ORDER BY m.id
        LIMIT 1;
    """
    result = fetch_results(sql, (sha256,))
    return result[0] if result else None

# Inserts a new VirusTotal scan analysis record
def create_vt_engine_record(analysis_id: int, apk_id: int) -> bool:
    sql = "INSERT INTO vt_scan_analysis (analysis_id, apk_id) VALUES (%s, %s)"
    return bool(fetch_results(sql, (analysis_id, apk_id)))

# Adds a new column for a VirusTotal engine if it doesn't exist
def create_vt_engine_column(new_vt_engine: str, data_type: str = "VARCHAR(100)") -> bool:
    if not new_vt_engine.strip():
        logger.error("Invalid VT engine name: must be a non-empty string.")
        return False

    existing_columns = fetch_results("SHOW COLUMNS FROM vt_scan_analysis")
    if existing_columns and any(col["Field"] == new_vt_engine for col in existing_columns):
        logger.error("Column '%s' already exists.", new_vt_engine)
        return False

    sql = f"ALTER TABLE vt_scan_analysis ADD COLUMN `{new_vt_engine}` {data_type} AFTER type_unsupported;"
    fetch_results(sql)

    logger.info("Added new VT engine column: '%s'", new_vt_engine)
    return True

# Updates VirusTotal scan metadata for an analysis record
def update_vt_engine_detection_metadata(analysis_id: int, summary_stat: Dict[str, str]):
    sql_template = "UPDATE vt_scan_analysis SET `{column}` = %s WHERE analysis_id = %s"
    
    try:
        with db_conn.database_connection() as conn:
            cursor = conn.cursor()
            for key, value in summary_stat.items():
                column = key.replace('-', '_')  # Ensure column names match database format
                sql = sql_template.format(column=column)
                cursor.execute(sql, (value, analysis_id))
            conn.commit()
    except Exception:
        logger.exception("Error updating VT metadata for analysis_id %s", analysis_id)

def ensure_dict_format(detections: Any) -> dict:
    """Ensures that `detections` is in dictionary format."""
    if isinstance(detections, list):
        return {vendor: {"result": result} for vendor, result in detections}

    if not isinstance(detections, dict):
        logger.error("Expected `detections` as dict, but got %s", type(detections).__name__)
        print(f"[ERROR] Invalid data format. Expected dictionary, got {type(detections).__name__}")
        return {}
    
    return detections


def generate_metadata_summary(detections: dict) -> dict:
    """Generates metadata summary from the detections."""
    return {
        "total_vendors": len(detections),
        "classified_vendors": sum(1 for v in detections.values() if v["result"]),
        "harmless_vendors": sum(1 for v in detections.values() if not v["result"]),
        "malicious_vendors": sum(1 for v in detections.values() if v["result"] and "malicious" in str(v["result"]).lower()),
        "suspicious_vendors": sum(1 for v in detections.values() if v["result"] and "suspicious" in str(v["result"]).lower()),
    }

def compute_metadata(detections: dict) -> dict:
    """Computes metadata summary for VirusTotal scan results."""

    # Ensure detections is a dictionary of vendor scan results, not a precomputed metadata dictionary
    if any(key in ["total_vendors", "classified_vendors", "harmless_vendors", "malicious_vendors", "suspicious_vendors"]
           for key in detections):
        print("[ERROR] compute_metadata() received precomputed metadata instead of vendor results. Aborting computation.")
        return detections  # Return original dictionary instead of re-processing

    total_vendors = len(detections)
    classified_vendors = 0
    harmless_vendors = 0
    malicious_vendors = 0
    suspicious_vendors = 0
    unknown_vendors = 0  # Ensure this is always included

    for vendor, details in detections.items():
        if not isinstance(details, dict):  # Ensure `details` is a dictionary
            print(f"[ERROR] Unexpected data type for vendor '{vendor}': {type(details).__name__} -> {details}")
            unknown_vendors += 1
            continue  # Skip this vendor

        result = details.get("result")

        if result is not None:
            classified_vendors += 1
            result_lower = str(result).lower()

            if "malicious" in result_lower: 
                malicious_vendors += 1
            elif "suspicious" in result_lower:
                suspicious_vendors += 1
            elif result in ["undetected", None, "harmless"]:
                harmless_vendors += 1
            else:
                unknown_vendors += 1  # Count unexpected classifications

    return {
        "total_vendors": total_vendors,
        "classified_vendors": classified_vendors,
        "harmless_vendors": harmless_vendors
    }


def print_metadata_summary(metadata: dict):
    """Prints the metadata summary for better analysis."""
    
    print("\n" + "=" * 80)
    print(f"{'VirusTotal Scan Results Summary':^80}")
    print("=" * 80)
    print(f"Total Vendors Scanned:             {metadata['total_vendors']}")
    print(f"Vendors Provided Classifications:  {metadata['classified_vendors']}")
    print(f"Vendors Marking as Harmless:       {metadata['harmless_vendors']}")
    print("-" * 80)

def fetch_existing_columns() -> dict:
    """Fetches existing columns from `vt_scan_analysis` and maps them for easy lookup."""
    existing_columns = fetch_results("SHOW COLUMNS FROM vt_scan_analysis")

    if not existing_columns:
        logger.error("No columns found in `vt_scan_analysis`.")
        print("[ERROR] No columns found in `vt_scan_analysis`. Aborting update.")
        return {}

    return {col[0].replace('_', '-'): col[0] for col in existing_columns}


def process_vendor_results(analysis_id: int, detections: dict, column_names: dict):
    """Processes each vendor classification, updating existing columns or creating new ones if needed."""
    newly_added_vendors = []

    for vendor, details in detections.items():
        column_name = column_names.get(vendor)

        if column_name:
            # Update existing column
            sql = f"UPDATE vt_scan_analysis SET `{column_name}` = %s WHERE analysis_id = %s"
            fetch_results(sql, (details["result"], analysis_id))
        else:
            # If column does not exist, add it first
            print(f"New Vendor Detected: {vendor}. Adding column to database...")
            if create_vt_engine_column(vendor):
                newly_added_vendors.append(vendor)
                fetch_results(f"UPDATE vt_scan_analysis SET `{vendor}` = %s WHERE analysis_id = %s", (details["result"], analysis_id))

    return newly_added_vendors


def print_final_summary(analysis_id: int, metadata: dict, newly_added_vendors: list):
    """Prints the final summary report of the VirusTotal scan results update."""
    print("\nVirusTotal Vendor Engine Results:")
    print(f" -- {metadata['malicious_vendors']}/{metadata['total_vendors']} vendors detecting malware.")
    print(f" -- {metadata['suspicious_vendors']} marked as suspicious.")
    print(f" -- {metadata['harmless_vendors']} marked as harmless/undetected.")
    if newly_added_vendors:
        print(f"New Vendors Added to Database: {', '.join(newly_added_vendors)}")
    print("=" * 60)


def update_vt_engine_column(analysis_id: int, detections: Any):
    """Main function to update VirusTotal scan results dynamically, adding missing columns if necessary."""

    detections = ensure_dict_format(detections)
    if not detections:
        return

    metadata = generate_metadata_summary(detections)
    print_metadata_summary(metadata)

    try:
        column_names = fetch_existing_columns()
        if not column_names:
            return

        newly_added_vendors = process_vendor_results(analysis_id, detections, column_names)

        print_final_summary(analysis_id, metadata, newly_added_vendors)

    except Exception as e:
        logger.exception("Unexpected failure in update_vt_engine_column()")
        print(f"[ERROR] Unexpected error occurred while updating VirusTotal scan results: {e}")
